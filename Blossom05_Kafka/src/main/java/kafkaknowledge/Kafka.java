package kafkaknowledge;

public class Kafka {
    /**
     *  Kafka学习
     *  前言：消息队列
     *  1、概述
     *  2、Kafka基础架构
     *  3、Kafka命令行操作
     *      3.1 主题命令行操作：kafka-topics.sh
     *      3.2 生产者命令：kafka-console-producer.sh
     *      3.3 消费者命令：kafka-console-consumer.sh

     */

    /**
     *  前言：消息队列
     *  中间件：将具体业务和底层逻辑解耦的组件。例如，需要利用服务的人（前端写业务的），不需要知道底层逻辑（提供服务的）的集体实现，
     *          只要拿着中间件结果用就可以了
     *
     *  消息队列：是中间件的一种。队列是一种数据结构，用于存储数据，在消息队列中，消息即为需要存储的数据。
     *
     *  消息队列的使用场景：消峰/缓冲、异步、解耦
     *      传统业务流程分为很多步骤，例如：客户端的发送请求后，服务端需要一次执行业务逻辑A、B、C、D
     *      client ----> A ----> B ----> C ----> D
     *      使用消息队列改进业务流程：各业务之间没有关联，可并行执行
     *      client ----> A ----> MQ ----> B
     *                              ----> C
     *                              ----> D
     *
     *      消峰/缓冲：将客户端请求消息放入消息队列，服务端再从消息队列中拉取请求消息，并处理，
     *              能够解决客户端请求产生速度与服务端处理请求速度不匹配而引发的服务崩溃问题
     *      异步：客户端的请求经A服务处理后立刻反馈结果，A的处理结果信息提交到MQ中，服务B、C、D直接从MQ中获取处理结果信息，并完成各自的业务
     *      解耦：消息的生产与消息的消费不直接对接
     *
     *  消息队列存在的问题：
     *      任何技术都是一把双刃剑。使用了消息队列后，会增加系统的复杂性和系统维护问题，以及系统使用过程中会出现的各种问题。
     *      消息队列使用中的问题：重复消费、消息丢失、消息的顺序等
     *
     */

    /**
     *  1、Kafka概述
     *      what：Kafka是什么
     *      Kafka是一个分布式的，基于发布/订阅模式的消息队列(Message Queue)，主要应用与大数据实时处理领域
     *      卡夫卡是一个开源的分布式事件流平台，被用于高性能数据管道，流分析，数据集成和关键任务应用
     *
     *      why：为什么要使用Kafka
     *      解决大数据场景下，消息产生速度与消息消费速度不匹配问题
     *
     *      Kafka消息队列的两种模式：
     *          点对点模式：消息队列支持存在多个生产者和多个消费者，但是对于一个消息而言，只能有一个消费者可以消费。
     *                      并且消息被消费后，会被删除
     *
     *          发布/订阅模式：同样，支持多个生产者和消费者，对于每条消息，每个消费者都能够消费，并且消息被消费后，
     *                      不会立刻删除
     *
     *          说明：消息消费方式分为两种：队列推送消息和消费者拉取消息。Kafka
     *
     */

    /**
     *  2、Kafka基础架构
     *      3.1 Kafka相关概念
     *          > 消息：消息是KafKa通信的基本单位，由一个固定长度的消息头和一个可变长度的消息体构成。
     *                  在老版本中，每一条消息称为Message；在由Java重新实现的客户端中，每一条消息称为Record
     *
     *          > 主题(topic)：主题是Kafka中用于分类管理消息的逻辑单元，类似于数据库管理系统中的库和表，只是逻辑上的概念。
     *                  在Kafka中，主题即是代表着数。
     *                  主题作为Kafka中的核心概念，将生产者和消费者解耦。生产者向指定主题中发布消息，消费者订阅指定主题的消息。
     *
     *          > 分区(partition)：主题即代表消息。当消息特别多（主题特别大），为了方便消息的管理，Kafka将主题进行分区管理。
     *                  一个主题能够被分为许多个分区，每个分区由一系列有序、不可变的消息组成，是一个有序队列；
     *                  每个分区在物理上对应一个文件夹，分区的命名规则：主题名称—分区编号，分区编号从0开始；
     *                  每个主题的分区数可以在Kafka启动时加载的配置文件中配置，也可以在创建主题的时候进行设置，还可以在客户端中进行设置；
     *
     *                  每个分区又有一至多个副本（Replica），分区的副本分布在集群的不同broker上，以提高数据的可靠性；
     *
     *          > leader：每个分区所有副本中的老大，生产者发布消息，消费者订阅消息，都是与leader进行对接
     *          > follower：每个分区所有副本中不是leader的副本，实时从leader中同步数据，当leader发生故障时，Kafka会从follower中选举出新的leader
     *
     *          > 代理(broker)：KafKa集群就是由一个或者多个KafKa实例构成，每一个KafKa实例称为代理(Broker)，通常也称代理为KafKa服务器；
     *                  在生产环境中KafKa集群一般包括一台或者多台机器，我们可以在一台机器上配置一个或者多个代理；
     *                  每一个代理具有唯一的与该集群中其他代理都不同的非负整数的id，这个id就是代理的名字，也就是在启动代理的时候配置的broker.id对应的值
     *
     *          > 生产者(producer)：消息的生产者，即向Kafka broker发送数据的客户端，一般是Java代码实现的
     *          > 消费者(consumer)：消息的消费者，即从Kafka broker中获取数据的客户端，一般也是Java代码实现
     *              说明：Kafka broker是由Scala代码实现的
     *          > 消费者组(consumer group)： 由多个消费者构成。
     *                  在KafKa中每一个消费者都属于一个特定的消费者组，可以为每个消费者指定一个消费组，通过group.id配置设置。
     *                  不为消费者指定消费组时，则该消费者属于默认的消费组test-consumer-group
     *                  同时，每个消费者也有一个全局唯一的id，通过配置项client.id指定，
     *                  如果客户端没有指定消费者的id，KafKa会自动为该消费者生成一个全局唯一的id。
     *
     *                  在消费者组内，不同的消费者不能消费相同分区的消息，换句话说，一个分区的消息只能由一个消费者消费，原因是进行并行消费，提高效率；
     *                  消费者以拉取的方式消费消息；
     *                  消费组是KafKa用来实现对一个主题消息进行消费的手段，即消费者组是逻辑上的一个订阅者
     *
     */

    /**
     *  3、Kafka命令行操作
     *  3.1 主题命令行操作：kafka-topics.sh
     *      kafka-topics.sh命令参数
     *          --bootstrap-server <String: server toconnect to>     获取Kafka broker连接
     *          --topic <String: topic>     操作的topic名称
     *          --create    创建主题
     *          --delete    删除主题
     *          --alter     修改主题
     *          --list      查看所有主题
     *          --describe      查看主题详细描述
     *          --patitions<Integer:#of partitions>     设置分区数
     *          --replication-factor<Integer:replication factor>    设置分区副本
     *          --config<String:name = value>   更新系统默认配置
     *
     *  3.2 生产者命令：kafka-console-producer.sh
     *      生产者的命令行操作只能模拟出一个生产者客户端用于发送消息，因此，相关参数只有获取Kafka连接和主题操作命令
     *      --bootstrap-server<String:server toconnect to> 获取Kafka broker连接
     *      --topic<String:topic> 选择需要操作的主题
     *
     *  3.3 消费者命令：kafka-console-consumer.sh
     *      消费者的命令行操作只能模拟出一个消费者客户端用于接收消息，因此，相关参数也有获取Kafka连接和主题操作命令
     *      --bootstrap-server<String:server toconnect to> 获取Kafka broker连接
     *      --topic<String:topic> 选择需要操作的主题
     *
     *      --from-beginning    从头开始消费数据
     *      --group<String:consumer group id>   指定消费者组的名称
     *
     */
}
