package yarnknowledge;

public class YARN {
    // yarn 资源调度器
    // 概述：Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，
    //      而 MapReduce 等运算程序则相当于运行于操作系统之上的应用程序。
    // 主要负责：集群资源管理，给任务合理分配资源

    /**
     *  yarn知识结构
     *  一、理论
     *      1、yarn架构
     *      2、yarn的工作机制
     *      3、HDFS/MapReduce/yarn的配合工作
     *      4、调度器和调度算法
     *          > FIFO
     *          > 容量调度器
     *          > 公平调度器
     *      5、命令行操作yarn
     *      6、yarn在生产环境下需要配置的参数
     *  二、实操
     *      1、生产环境参数配置
     *      2、在生产环境下，容量调度器如何配置
     *      3、在生产环境下，公平调度器如何配置
     *      4、yarn的tool接口
     */

    /**
     *  1、yarn基础架构及工作机制
     *  基础架构
     *      |----yarn
     *          |----ResourceManager(RM)：整个集群资源的老大。负责客户端的请求；监控NodeManager的运行情况；启动和监控ApplicationMaster；资源的分配和调度
     *          |----NodeManager(NM)：单节点资源调度的老大。管理单个节点的资源；处理来自RM的命令；处理来自AM的命令
     *          |----ApplicationMaster(AM)：当前提交的作业的老大。为当前作业（应用程序）申请资源并给作业的内部任务分配资源；负责所管理的任务的监控和容错
     *          |----Container：是yarn资源的抽象资源，yarn资源包括内存、CPU、磁盘、网络
     *
     *  工作机制（工作流程）：
     *      1、client通过job.submit()方法向集群提交MapReduce作业
     *          xxxDriver.jar包中的主程序执行到job.waitForCompletion(true)方法，生成一个YarnRunner
     *      2、YarnRunner会向RM申请一个作业id
     *      3、然后RM给client返回该job的资源提交路径和作业id
     *      4、随后，job提交运行所需资源到RM指定的资源路径上。
     *          提交内容包括：源文件的切片信息、.xml配置信息和相应的jar包
     *      5、资源提交完成之后，client申请运行一个MRAppMaster
     *          MRAppMaster是MapReduce的ApplicationMaster实现，它使得MapReduce计算框架可以运行于YARN之上。
     *          在YARN中，MRAppMaster负责管理MapReduce作业的生命周期，包括创建MapReduce作业，向ResourceManager申请资源，
     *          与NodeManage通信要求其启动Container，监控作业的运行状态，当任务失败时重新启动任务等
     *      6、随后，RM将用户的请求初始化为一个task，该task会被放到任务队列中，等待调度器
     *      7、当有NodeManager节点有足够的资源（较为空闲时），会将该task领走
     *      8、随后NM创建Container，并启动MRAppMaster，MRAppMaster随后将job提交的资源下载到本地
     *      9、MRAppMaster根据资源中的切片信息再次向AM申请MapTask运行的资源
     *      10、同样，当有空闲的NM存在时，会将这些MapTask任务领走，并创建Container
     *      11、随后MRAppMaster会向接受MapTask任务的NM发送启动脚本，相应的NM启动MapTask，对数据进行处理（业务逻辑、分区、排序、合并等）
     *      12、当所有的MapTask都执行完成后，MRAppMaster再向AM申请运行ReduceTask的资源
     *      13、同样，当存在空闲的NM时，NM会将ReduceTask任务领走，随后创建Container容器，并从MapTask处将数据拷贝到本地，并开始执行ReduceTask任务
     *      14、当所有的ReduceTask都执行完之后，MRAppMaster向AM申请注销自己及当前任务所使用资源
     *
     */

    /**
     *  2、HDFS/MapReduce/yarn的配合工作
     */

    /**
     *  3、yarn任务调度
     *  yarn资源调度器类型：FIFO、 Capacity Scheduler 和 Fair Scheduler
     *      FIFO调度器：任务调度方式：按到达时间排序，先到达先服务
     *
     *      Capacity Scheduler调度器：是Yahoo开发的多用户调度器，它以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限；
     *          同时，每个用户也可设定一定的资源使用上限以防止资源滥用；而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。
     *
     *      特点：
     *          > 容量保证。管理员可为每个队列设置资源最低保证和资源使用上限，而所有提交到该队列的应用程序共享这些资源
     *
     *          > 灵活性，如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用程序提交，
     *              则其他队列借调的资源会归还给该队列。这种资源灵活分配的方式可明显提高资源利用率。
     *
     *          > 多重租赁。支持多用户共享集群和多应用程序同时运行。为防止单个应用程序、用户或者队列独占集群中的资源，
     *              管理员可为之增加多重约束（比如单个应用程序同时运行的任务数等）。
     *
     *          > 安全保证。每个队列有严格的 ACL 列表规定它的访问用户，每个用户可指定哪些用户允许查看自己应用程序的
     *              运行状态或者控制应用程序（比如杀死应用程序）。此外，管理员可指定队列管理员和集群系统管理员。
     *
     *          > 动态更新配置文件。管理员可根据需要动态修改各种配置参数，以实现在线集群管理
     *
     *          > 小应用程序响应时间快，由于采用了最大最小公平算法，小作业可以快速获取资源并运行完成
     *
     *      Capacity 调度器算法思想：
     *          > 1、队列资源分配：从root开始，使用深度优先算法，优先选择资源占用率最低的队列进行资源分配
     *          > 2、作业资源分配：默认按照提交作业的优先级和提交时间顺序分配资源
     *          > 3、容器资源分配：按照容器的优先及级配资源，当优先级相同时，则遵循就近原则对容器分配资源
     *              说明：一个容器对应一个task任务的所需的资源
     *
     *      Fair Scheduler公平调度器：是Facebook开发的多用户调度器。公平调度器的目的是让所有的作业随着时间的推移，都能平均地获取等同的共享资源。
     *          当有作业提交上来，系统会将空闲的资源分配给新的作业， 每个任务大致上会获取平等数量的资源。和传统的调度策略不同的是它会让小的任务在
     *          合理的时间完成，同时不会让需要长时间运行的耗费大量资源的任务挨饿
     *
     *          缺额：某一时刻一个作业应获资源和实际获取资源的差距叫缺额。公平调度器会优先为缺额大的作业分配资源
     *
     *          特点：
     *              与容量调度器的相同点：
     *                  > 多队列：支持多队列任务调度，并且能对不同的队列设置不同的调度策略
     *                  > 容量保证：可以为每个队列设置最小分配和资源的使用上限
     *                  > 灵活性：当一个队列的资源存在空闲，可以空闲资源共享给需要资源的队列，而当该队列有新的任务需要执行，那么会将共享出去的资源收回
     *                  > 多用户：支持多用户共享集群和多应用程序同时运行。为了防止同一用户的作业独占队列的资源，管理员可以对同一用户能够使用的资源进行限定
     *
     *              与容量调度器的不同点：
     *                  > 核心调度策略不同：
     *                      容量调度器：优先分配资源给资源需求较小的队列、作业、任务等
     *                      公平调度器：优先选择资源缺额较大的队列队列、作业、任务等
     *                  > 队列的能够设置的调度策略不同
     *                      容量调度器：FIFO、DRF
     *                      公平调度器：FIFO、Fair、DRF
     *                      FIFO调度策略：任务先请求，先服务。当公平调度器采用FIFO调度策略，那么相当于容量调度器
     *                      Fair调度策略：容量调度器的默认调度策略。是一种基于最大最小公平算法实现的资源多路复用方式。资源调度需考虑job任务的
     *                          权重（若设置权重），并按权重进行资源分配。
     *                      DRF调度策略：一般，资源有很多，内存，硬盘，CPU等。前述资源调度都是针对一种资源而言，实际上会有很多资源参与分配
     *                  > 支持资源抢占：当某个队列中有剩余资源时，调度器会将这些资源共享给其他队列，而当该队列中有新的应用程序提交时，调度器要为它回收资源。
     *                      与容量调度器不同的是：为了尽可能降低不必要的计算浪费，调度器采用了先等待再强制回收的策略，即如果等待一段时间后尚有未归还的资源，
     *                      则会进行资源抢占：从那些超额使用资源的队列中杀死一部分任务，进而释放资源。
     *
     */

    /**
     *  4、yarn常用命令
     */

    /**
     *  5、yarn常用配置参数设置
     */
}
