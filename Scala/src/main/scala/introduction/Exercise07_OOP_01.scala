package introduction

object Exercise07_OOP_01 {
  // Scala面向对象
  /*
    1、Scala包
      > 定义方式：package 包名
      > 作用：区分相同名字的类，对类进行管理，控制访问范围
      > 包的命名规则：与Java相同
      > 使用风格：Scala有两种包管理风格，一种是Java的风格，即一个源文件一个包，包名和源文件所在位置不必相同
                  另一种是Scala独有的风格，利用包嵌套的方式表示层级关系从
                  package p1{
                    package p2{
                      package p3{
                        代码
                      }
                    }
                  }
                  Scala这种独有的包管理风格的好处：一个源文件可以有多个包，子包调用父包的内容不需要导包，父包
                  调用子包的内容需要导包，
      > 包对象：在Scala中，可以为每一个包定义唯一一个包对象，包对象的名字和包名必须相同，在包对象中定义的内容是
                该包下所有对象或类的共享内容，可以直接访问
                对于Java风格的包格式，包对象的一般定义在其对应包下的 package.scala文件中，包对象名与包名保持一致
                对于Scala风格的包格式，包对象可以与包定义在同一个源文件中，但是需要保证包对象与包声明在同一作用域中
      > 导包方式：
          -- 和Java一样，可以在顶部使用 import 导入， 在这个文件中的所有类都可以使用
          -- 局部导入：什么时候使用，什么时候导入。 在其作用范围内都可以使用
          -- 通配符导入： import java.util._
          -- 给类起名： import java.util.{ArrayList=>JL}
          -- 导入相同包的多个类： import java.util.{HashSet, ArrayList}
          -- 屏蔽类： import java.util.{ArrayList =>_,_}
        需要说明的是：Scala默认导入java.lang._   import scala._  import scala.Predef._三个包

    2、Scala类及类的结构
      > 类
        Scala类和对象与Java中相同，区别在于，Scala的默认访问权限是public，并且没有public关键字
        因此，在一个文件中可以写多个类

        类定义格式：
          [访问权限] class 类名{
            类体
          }

      > 属性，定义格式：[访问权限] var|val 属性名 : 数据类型 = 属性值
          需要说明的是，Scala是结合了函数式编程和面向对象编程的语言，
          对于函数式编程，val类型数据是主体，对于面向对象编程，var类型数据占据主体

          Scala中简化了属性的get、set方法，利用注解@BeanProperty，能够使编译器自动生成get、set方法

          属性的默认值说明：
              对于var类型数据，可以通过下划线'_'，赋予默认值
              对于val类型数据，则不能使用'_'进行默认赋值，必须在定义常量是为常量赋值

      > 方法：定义在类中的函数就是方法
        语法格式：def 函数名(参数名1 : 数据类型, 参数名2 : 数据类型, ...) : 返回值类型 = {函数体}

      > 构造器：
        主构造器：就是类本身，定义类时，可以在类名后面添加参数列表
            class 类名(参数列表) { 类体 }
            在创建对象时，可以直接传入参数进行属性初始化

            主构造器参数列表说明：
              构造器参数列表参数包括三种类型，未用任何修饰、 var 修饰、 val 修饰
                > 未用任何修饰符修饰，这个参数就是一个局部变量，使用主构造器创建对象时，利用该参数对属性进行初始化等操作
                > var 修饰的参数，作为类的成员属性使用，可以修改
                > val 修饰的参数，作为类只读属性使用，不能修改

        辅助构造器：类似于Java的构造器。在Scala中，辅助构造器的定义与函数相同，函数名必须为this，
                    即辅助构造器之间构成重载；并且，辅助构造器都必须直接或间接的调用主构造器；
                    辅助构造器之间的调用必须满足，下方辅助构造器调用上方辅助构造器，原因是，加载顺序


      3、封装
        访问权限：private、protected、private[包名]、默认
        private：私有的，只在当前作用域能够偶使用，即当前类中
        protected：受保护的，当前类以及当前类的子类中能够使用
        private[包名]：包访问权限，指定包下的结构能够使用
        默认：公共的，当前工程下都唔那个使用

      4、继承和多态：extends关键字
        基本语法：class 子类名 extends 父类名 { 类体 }
        子类继承会继承父类的属性和方法，同样Scala也是单继承多实现，当子类继承父类时，在创建子类对象的时候，
          会优先加载父类，再加载子类

         区别于Java，Scala对多态的实现是是对属性和方法都有效，即动态绑定属性和方法

         子类如果需要重写父类的属性和方法，那么需要添加关键字override
         注意：对于val的属性，无法进行重写，对于var的属性，没必要重写
         在子类和父类都有的条件下，如果想调用父类的属性或者方法，那么需要使用super关键字表示父类

      5、抽象类：abstrat关键字
        语法格式：
          抽象类：abstract class 类名 { 类体 }
        在抽象类中可以定义抽象方法和抽象属性，并且不需要abstract关键字声明
        抽象方法：声明方法不写具体的实现类，def 方法名(参数列表):返回值
        抽象属性：不需要给属性赋值：val|var 属性名：数据类型;

        子类继承抽象类，那么必须要实现其中所有的抽象方法和抽象属性，否则，必须是抽象类
        匿名子类对象，直接实现抽象属性和抽象方法

      6、伴生对象：
        Scala语言是完全面向对象的语言，所以并没有静态的操作（即在Scala中没有静态的概念）。
        但是为了能够和Java语言交互（因为Java中有静态概念），就产生了一种特殊的对象来模拟类对象，
        该对象为单例对象。若单例对象名与类名一致，则称该单例对象这个类的伴生对象，
        这个类的所有“静态” 内容都可以放置在它的伴生对象中声明。

        伴生对象利用object关键字来声明
        单例对象对应的类称之为伴生类，伴生对象的名称应该和伴生类名一致
        单例对象中的属性和方法都可以通过伴生对象名（类名）直接调用访问

      7、特质：trait
        特质类似于Java中的接口
          Scala的trait中既可以有抽象属性和方法，也可以有具体的属性和方法，
          一个类可以混入（ mixin）多个特质。这种感觉类似于 Java 中的抽象类
        语法格式：trait 特质名 { 特质体 }

        Scala中利用extends表示类与特质的关系，表示类具有某种特质
        没有父类： class 类名 extends 特质 1 with 特质 2 with 特质 3 …
        有父类：class 类名 extends 父类 with 特质 1 with 特质 2 with 特质 3…

        说明：当一个类去继承特质时，第一个连接词是 extends，后面是 with
              如果一个类在同时继承特质和父类时，应当把父类写在 extends 后

              动态混入：和Java中的匿名子类对象相同

              对于特质的叠加，即一个类多有多个特质，每个特质中又都有相同的属性或方法，
              那么：
                1、当子类中没有重写这些方法或属性，那么子类在调用这些属性和方法时，调用的优先级，从右往左
                2、当子类重写了这些方法，那么就调用子类本身的属性
                如果想要调用某个指定的混入特质中的方法，可以增加约束： super[]

    扩展：
      1、枚举类：定义一个类，继承Enumeration，那么该类就是一个枚举类
      // 其中数字表示，该变量在底层存储的方式，字符串表示该变量的值
      object Color extends Enumeration {
          val RED = Value(1, "red")
          val YELLOW = Value(2, "yellow")
          val BLUE = Value(3, "blue")
      }

      2、应用类：定义一个类，继承App，那么该类中的代码可以直接运行，

      3、给数据类型起别名：type s = String，那么s现在代表着字符串类型

      4、引用类型转换及检测
        obj.isInstanceOf[T]：判断obj对象是不是类或者特质T的子类、实现类或本身的对象
        obj.asInstanceOf[T]：将obj强转成T类型，必须具有子父类继承关系才能转
        classOf：获取对象所属类的类名

   */
}
